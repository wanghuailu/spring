循环依赖

当实例化完成后，要开始进行初始化赋值操作，但是赋值的时候，属性值的类型可能是引用类型，需要从 spring 容器中获取某个具体对象来完成赋值操作。
但是此时需要的引用类型的对象可能被创建了，可能还没有创建。
  1）如果创建了，那么直接获取，完成赋值操作即可；
  2）如果没有创建，那么在这个赋值过程中，就涉及到对象的创建过程。而内部依赖的对象的创建过程中，又会有其他依赖的对象。有可能内部依赖对象又依赖
    当前的对象，而此时当前对象还没有完成完整的创建过程（实例化和初始化），所以此时产生了循环依赖问题；

例如：
public class A {

    private B b;

}

public class B {

    private A a;

}

上面的例子就产生了循环依赖问题。

我们在创建对象的时候，分为了两个步骤：实例化和初始化。那么在初始化环节的填充属性阶段有没有可能会改变当前对象的地址空间？
答：不会改变。属性填充并不会改变对象的堆地址

但是我们不得不考虑，在应用 spring 的时候，会配置 AOP，需要生成具体的代理对象，那么问题来了：

问题1：生成代理对象，要不要生成被依赖的具体对象？
答：要，代理对象依赖具体对象

问题2：能否确定什么时候调用具体对象，无论是不需要被代理的普通对象还是代理对象？
答：不能确定

问题3：有没有可能在 spring 中同时存在同一个 beanName 的具体对象和代理对象？
答：可能

问题4：结合问题3，既然可能会存在，那么在调用的时候是根据 beanName 来获取对象的，此时我需要获取到两个对象吗？那么我该使用哪一个对象？
答：分层或分块存储。可以创建两个缓存，分别存储具体对象和代理对象

问题5：结合问题4答案，这两个缓存优先获取哪一个？
答：优先获取代理对象，然后才是具体对象


推导：代理对象中应该包含具体对象的所有功能，如果一个对象需要被代理，那么此时具体对象既可以不存在，只要代理对象就可以了。
也就是说，在后续创建代理对象之后，就可以使用代理对象来覆盖具体对象。

根据推导的结果，问题3、问题4、问题5的答案就是错误的，spring 中只存在一个 beanName 的对象。


回到问题2，什么时候要调用对象？
答：在调用对象时，如果检测到当前对象需要被代理，那么直接创建代理对象覆盖即可。

问题6：怎么能够随时在需要的时候创建代理对象呢？
答：类似于观察者，传递一个生成代理对象的匿名内部类（lambda表达式），当需要调用的时候，直接调用匿名内部类（lambda表达式）来生成代理对象，就是回调机制

问题7：初始化的步骤？
答：
  1）填充属性
  2）执行 Aware 接口所对应的方法
  3）执行 BeanPostProcessor 的 before() 方法
  4）执行 init-method 的方法
  5）执行 BeanPostProcessor 的 after() 方法
  
问题8：问题7的步骤执行完成之后，就可以获取到一个完整的成品对象，但是在初始化的时候，我们能确定哪一个对象需要生成代理对象吗？
答：不能确定

问题9：三级缓存只是一个回调机制，所以能否把所有 bean 所需的创建代理对象的 lambda 表达式都缓存下来吗？
答：可以。如果后续需要生成代理对象，直接从三级缓存中调用执行即可。如果不需要，在生成完整对象之后，可以把三级缓存中对应的 lambda 表达式清除掉即可（往一级缓存中存放成品对象时，同时清除三级缓存）

问题10：什么时候要生成具体的代理对象？
答：
  1）在进行属性注入的时候，如果依赖的属性值，是一个引用对象，同时这个引用对象也检测到需要生成代理对象，那么就创建这个引用对象的代理对象
  2）在整个创建过程，如果没有其他对象依赖当前对象，同时当前对象也需要创建代理对象，那么在生成最终的完整对象之前生成代理对象即可（BeanPostProcessor 的 after() 方法中完成）


总结：
DefaultSingletonBeanRegistry
一级缓存：成品对象，包含无需代理的普通对象和代理对象   k: beanName, v: Object
二级缓存：半成品对象，完成了实例化操作，但未完成初始化的对象 k: beanName, v: Object
三级缓存：存放生成代理对象的 lambda 表达式 k: beanName, v: 匿名内部类( lambda 表达式) 


查找对象的顺序：
             如果不存在                    如果不存在
    一级缓存 ---------->>>>>>>>>> 二级缓存 ---------->>>>>>>>>> 三级缓存
    
如果发生循环依赖的对象，不需要代理的话，只需要一级和二级缓存就可以解决了。
但是当存在代理之后，就无法解决，必须要使用三级缓存。
三级缓存的意义，就是在原对象和代理对象之间确定一个唯一对象。getEarlyBeanReference()